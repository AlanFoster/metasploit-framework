I"{<p>Arbitrary file upload is surprisingly common among web applications, which can be abused to upload malicious files and then compromise the server. Usually, the attacker will select a payload based on whatever server-side programming language is supported. So if the vulnerable app is in PHP, then clearly PHP is supported, therefore an easy choice would be using a PHP payload such as Metasploitâ€™s PHP meterpreter. However, the PHP meterpreter does not share the same performance as, say, a Windows meterpreter. So in reality, what happens is you will probably want to upgrade to a better shell, which involves extra manual work during the process. So why limit your payload options? For this type of scenario, you should use the <code class="highlighter-rouge">PhpEXE</code> mixin. It serves as a payload stager in PHP that will write the final malicious executable onto the remote file system, and then clear itself after use, so it leaves no traces.</p>

<h3 id="requirements">Requirements</h3>

<p>To use the <code class="highlighter-rouge">PhpEXE</code> mixin, some typical exploitable requirements should be met:</p>

<ul>
  <li>You must find a writeable location on the web server.</li>
  <li>The same writeable location should also be readable with a HTTP request.</li>
</ul>

<p>Note: For an arbitrary file upload bug, there is usually a directory that contains uploaded files, and is readable. If the bug is due to a directory traversal, then a temp folder (either from the OS or the web app) would be your typical choice.</p>

<h3 id="usage">Usage</h3>

<ul>
  <li>First include the mixin under the scope of your <code class="highlighter-rouge">Metasploit3</code> class like the following:</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kp">include</span> <span class="no">Msf</span><span class="o">::</span><span class="no">Exploit</span><span class="o">::</span><span class="no">PhpEXE</span>
</code></pre></div></div>

<ul>
  <li>Generate the payload (with the PHP stager) with <code class="highlighter-rouge">get_write_exec_payload</code></li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="o">=</span> <span class="n">get_write_exec_payload</span>
</code></pre></div></div>

<p>If youâ€™re working on a Linux target, then you can set <code class="highlighter-rouge">unlink_self</code> to true, which will automatically clear the executable:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="o">=</span> <span class="n">get_write_exec_payload</span><span class="p">(</span><span class="ss">:unlink_self</span><span class="o">=&gt;</span><span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<p>On Windows, you probably cannot clear the executable because it will probably still be in use. If itâ€™s not possible to automatically clean up malicious files, you should always warn the user about where they are, so they can do it manually later during the penetration test.</p>

<ul>
  <li>Upload the payload</li>
</ul>

<p>At this point you can upload the payload generated by <code class="highlighter-rouge">get_write_exec_payload</code>, and then call it by using a GET request. If you do not know how to send a GET request, please refer to the following article:
https://github.com/rapid7/metasploit-framework/wiki/How-to-Send-an-HTTP-Request-Using-HTTPClient</p>

<h3 id="reference">Reference</h3>

<p>https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/php_exe.rb</p>
:ET