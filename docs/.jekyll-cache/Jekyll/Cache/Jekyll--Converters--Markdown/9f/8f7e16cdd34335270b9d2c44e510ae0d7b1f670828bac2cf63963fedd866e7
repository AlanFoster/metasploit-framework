I"a/<h1 id="how-to-use-the-msfexploitremotetcp-mixin">How to use the Msf::Exploit::Remote::Tcp mixin</h1>
<p>In Metasploit Framework, TCP sockets are implemented as Rex::Socket::Tcp, which extends the built-in Ruby Socket base class. You should always use the Rex socket instead of the native Ruby one because if not, your sockets are not manageable by the framework itself, and of course some features will be missing such as pivoting. The <a href="https://github.com/rapid7/metasploit-framework/blob/master/documentation/developers_guide.pdf">Developer’s Guide</a> in Metasploit’s documentation directory explains how this works pretty well.</p>

<p>For module development, normally you wouldn’t be using Rex directly, so instead you’d be using the Msf::Exploit::Remote::Tcp mixin. The mixin already provides some useful features you don’t really have to worry about during development, such as TCP evasions, proxies, SSL, etc. All you have to do is make that connection, send something, receive something, and you’re done.</p>

<p>Sounds pretty easy, right?</p>

<h2 id="using-the-mixin">Using the mixin</h2>

<p>To use the mixin, simply add the following statement within your module’s <code class="highlighter-rouge">class Metasploit3</code> (or <code class="highlighter-rouge">class Metasploit4</code>) scope:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kp">include</span> <span class="no">Msf</span><span class="o">::</span><span class="no">Exploit</span><span class="o">::</span><span class="no">Remote</span><span class="o">::</span><span class="no">Tcp</span>
</code></pre></div></div>

<p>When the mixin is included, notice there will be the following datastore options registered under your module:</p>

<ul>
  <li><strong>SSL</strong> - Negotiate SSL for outgoing connections.</li>
  <li><strong>SSLVersion</strong> - The SSL version used: SSL2, SSL3, TLS1. Default is TLS1.</li>
  <li><strong>SSLVerifyMode</strong> - Verification mode: CLIENT_ONCE, FAIL_IF_NO_PEER_CERT, NONE, PEER. Default is PEER.</li>
  <li><strong>Proxies</strong> - Allows your module to support proxies.</li>
  <li><strong>ConnectTimeout</strong> - Default is 10 seconds.</li>
  <li><strong>TCP::max_send_size</strong> - Evasive option. Maxiumum TCP segment size.</li>
  <li><strong>TCP::send_delay</strong> - Evasive option. Delays inserted before every send.</li>
</ul>

<p>If you wish to learn how to change the default value of a datastore option, please read “<a href="https://github.com/rapid7/metasploit-framework/wiki/How-to-use-datastore-options#changing-the-default-value-for-a-datastore-option">Changing the default value for a datastore option</a>”</p>

<h2 id="make-a-connection">Make a connection</h2>

<p>To make a connection, simply do the following:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">connect</span>
</code></pre></div></div>

<p>When you do this, what happens is that the <code class="highlighter-rouge">connect</code> method will call <code class="highlighter-rouge">Rex::Socket::Tcp.create</code> to create the socket, and register it to framework. It automatically checks with the RHOST/RPORT datastore options (so it knows where to connect to), but you can also manually change this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This connects to metasploit.com</span>
<span class="n">connect</span><span class="p">(</span><span class="kp">true</span><span class="p">,</span> <span class="p">{</span><span class="s1">'RHOST'</span><span class="o">=&gt;</span><span class="s1">'208.118.237.137'</span><span class="p">,</span> <span class="s1">'RPORT'</span><span class="o">=&gt;</span><span class="mi">80</span><span class="p">})</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">connect</code> method will then return the Socket object, which is also accessible globally.</p>

<p>But you see, there’s a little more to it. The <code class="highlighter-rouge">connect</code> method can also raise some Rex exceptions that you might want to catch, including:</p>

<ul>
  <li><strong>Rex::AddressInUse</strong> - Possible when it actually binds to the same IP/port.</li>
  <li><strong>::Errno::ETIMEDOUT</strong> - When Timeout.timeout() waits to long to connect.</li>
  <li><strong>Rex::HostUnreachable</strong> - Pretty self-explanatory.</li>
  <li><strong>Rex::ConnectionTimeout</strong> - Pretty self-explanatory.</li>
  <li><strong>Rex::ConnectionRefused</strong> - Pretty self-explanatory.</li>
</ul>

<p>So to sum it up, ideally when you use the <code class="highlighter-rouge">connect</code> method, you should rescue these:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">rescue</span> <span class="no">Rex</span><span class="o">::</span><span class="no">AddressInUse</span><span class="p">,</span> <span class="o">::</span><span class="no">Errno</span><span class="o">::</span><span class="no">ETIMEDOUT</span><span class="p">,</span> <span class="no">Rex</span><span class="o">::</span><span class="no">HostUnreachable</span><span class="p">,</span> <span class="no">Rex</span><span class="o">::</span><span class="no">ConnectionTimeout</span><span class="p">,</span> <span class="no">Rex</span><span class="o">::</span><span class="no">ConnectionRefused</span>
</code></pre></div></div>

<p>If you are curious where all these exceptions are raised, you can find them in <a href="https://github.com/rapid7/metasploit-framework/blob/master/lib/rex/socket/comm/local.rb">lib/rex/socket/comm/local.rb</a>.</p>

<h2 id="sending-data">Sending data</h2>

<p>There are several ways to send data with the Tcp mixin. To make things easier and safer, we recommend just use the <code class="highlighter-rouge">put</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sock</span><span class="p">.</span><span class="nf">put</span> <span class="s2">"Hello, World!"</span>
</code></pre></div></div>

<p>The reason the <code class="highlighter-rouge">put</code> method is safer is because it does not allow the routine to hang forever. By default, it doesn’t wait, but if you want to make this more flexible, you can do this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span>
	<span class="n">sock</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="s2">"data"</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Timeout'</span><span class="o">=&gt;</span><span class="mi">5</span><span class="p">})</span>
<span class="k">rescue</span> <span class="o">::</span><span class="no">Timeout</span><span class="o">::</span><span class="no">Error</span>
	<span class="c1"># You can decide what to do if the writing times out</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="receiving-data">Receiving data</h2>

<p>Now, let’s talk about how to receive data. Mainly there are three methods you can use: <code class="highlighter-rouge">get_once</code>, <code class="highlighter-rouge">get</code>, and <code class="highlighter-rouge">timed_read</code>. The difference is that <code class="highlighter-rouge">get_once</code> will only try to poll the stream to see if there’s any read data available <strong>one time</strong>, but the <code class="highlighter-rouge">get</code> method will keep reading until there is no more. As for <code class="highlighter-rouge">timed_read</code>, it’s basically the <code class="highlighter-rouge">read</code> method wrapped around with a Timeout.</p>

<p>The following demonstrates how <code class="highlighter-rouge">get_once</code> is used:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="nf">get_once</span>
<span class="k">rescue</span> <span class="o">::</span><span class="no">EOFError</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">get_once</code> may also return nil if there is no data read, or it hits a EOFError if it receives nil as data. So please make sure you’re catching nil in your module.</p>

<p>The data reading methods can be found in <a href="https://github.com/rapid7/metasploit-framework/blob/master/lib/rex/io/stream.rb">lib/rex/io/stream.rb</a>.</p>

<h2 id="disconnecting">Disconnecting</h2>

<p>To disconnect the connection, simply do:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">disconnect</span>
</code></pre></div></div>

<p>It is VERY important you disconnect in an <code class="highlighter-rouge">ensure</code> block, obviously to make sure you always disconnect if something goes wrong. If you don’t do this, you may end up with a module that can only one request to the server (that very first one), and the rest are broken.</p>

<h2 id="full-example">Full example</h2>

<p>The following example should demonstrate how you would typically want to use the Tcp mixin:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Sends data to the remote machine</span>
<span class="c1">#</span>
<span class="c1"># @param data [String] The data to send</span>
<span class="c1"># @return [String] The received data</span>
<span class="k">def</span> <span class="nf">send_recv_once</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="s1">''</span>
	<span class="k">begin</span>
		<span class="n">connect</span>
		<span class="n">sock</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="nf">get_once</span> <span class="o">||</span> <span class="s1">''</span>
	<span class="k">rescue</span> <span class="no">Rex</span><span class="o">::</span><span class="no">AddressInUse</span><span class="p">,</span> <span class="o">::</span><span class="no">Errno</span><span class="o">::</span><span class="no">ETIMEDOUT</span><span class="p">,</span> <span class="no">Rex</span><span class="o">::</span><span class="no">HostUnreachable</span><span class="p">,</span> <span class="no">Rex</span><span class="o">::</span><span class="no">ConnectionTimeout</span><span class="p">,</span> <span class="no">Rex</span><span class="o">::</span><span class="no">ConnectionRefused</span><span class="p">,</span> <span class="o">::</span><span class="no">Timeout</span><span class="o">::</span><span class="no">Error</span><span class="p">,</span> <span class="o">::</span><span class="no">EOFError</span> <span class="o">=&gt;</span> <span class="n">e</span>
		<span class="n">elog</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="se">\n</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">backtrace</span> <span class="o">*</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
	<span class="k">ensure</span>
		<span class="n">disconnect</span>
	<span class="k">end</span>

	<span class="n">buf</span>
<span class="k">end</span>
</code></pre></div></div>
:ET