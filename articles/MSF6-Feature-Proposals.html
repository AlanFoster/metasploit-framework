<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Git Reference Sites | Metasploit spike</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Git Reference Sites" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Learning Git" />
<meta property="og:description" content="Learning Git" />
<link rel="canonical" href="/metasploit-framework/articles/Git-Reference-Sites.html" />
<meta property="og:url" content="/metasploit-framework/articles/Git-Reference-Sites.html" />
<meta property="og:site_name" content="Metasploit spike" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-01-12T17:14:28+00:00" />
<script type="application/ld+json">
{"description":"Learning Git","headline":"Git Reference Sites","dateModified":"2012-01-12T17:14:28+00:00","datePublished":"2012-01-12T17:14:28+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/metasploit-framework/articles/Git-Reference-Sites.html"},"url":"/metasploit-framework/articles/Git-Reference-Sites.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/metasploit-framework/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/metasploit-framework/feed.xml" title="Metasploit spike" /></head>
<body><header class="site-header" role="banner">

    <div class="wrapper"><a class="site-title" rel="author" href="/metasploit-framework/">Metasploit spike</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger">
            <a class="page-link" href="/metasploit-framework/">Articles</a><a class="page-link" href="/metasploit-framework/modules/">Modules</a></div>
        </nav></div>
  </header>
  <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">MSF6 Feature Proposals</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-10-16T16:52:00+01:00" itemprop="datePublished">Oct 16, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>List of potential major features (things that would make major breaking changes) for MSF6:</p>

<h1 id="payloads-and-post-exploitation">Payloads and Post-exploitation</h1>

<h2 id="meterpreter-transport-and-scalability-overhaul">Meterpreter Transport and Scalability Overhaul</h2>

<p>The Meterpreter Protocol “TLV” is enhanced to support modern features such as logging, unidirectional messages, obfuscation, sequence number reassembly and more. This feature will enable Meterpreter sessions to be more robust, faster, and evade detection with greater ease than before.</p>

<p>Additionally, Meterpreter payload listeners, rather than being integrated straight into <code class="highlighter-rouge">msfconsole</code>, will run as an independent process that communicates with msfconsole (1 or more users) over RPC similar to the msfdb_ws (Metasploit Database Web Service). The external listener then replaces the ‘metasploit-aggregator’ project by not requiring an intermediate proxy to park or share sessions, these are done directly by having the listeners independent of console users.</p>

<p>Listener capabilities be embeddable directly into Meterpreter payloads, allowing local listeners and remote listeners internal to other networks could be implemented the same way, enabling greater scalability and facilitating pivoting across more complex networks, allowing better post-exploitation possibilities in modern network environments.</p>

<h2 id="integration-with-external-c2-frameworks">Integration with external C2 frameworks</h2>

<p>If listeners are externalized, then there is an API layer both for interactive interaction with remote sessions, and a way for the Post-exploitation API to communicate with the external sessions. That should mean that if an external C2 framework supports at minimum shell interaction, a bulk of the Post-exploitation API should be applicable against external C2 frameworks as well. Metasploit would then be able to integrate both with other open-source C2 frameworks, as well as private ones.</p>

<h2 id="integration-of-native-tool-chains">Integration of native tool-chains</h2>

<p>Tools like Veil, pwnlib, etc. have for a long time used native compilers and tooling to build payloads and evasions. Metasploit has opted mostly for native Ruby solutions, though it does have some implicit runtime dependencies like <code class="highlighter-rouge">apktool</code> for Android payload injection. However, these tools are getting harder to maintain and use (e.g. metasm has a diffcult time building any non-trivial C code, we just spent a month fixing a bug it had with Ruby 2.5 and Windows). It would be nice to have either be able to depend on a set of first-class toolchains being available in the environment, or have some way to package them natively with Metasploit itself. A full suite of compilers and tools does consume considerable amounts of space (e.g. mettle’s toolchain is 1.8GB uncompressed), but this is probably less of a problem than it was 15 years ago.</p>

<h2 id="native-first-class-uuid-aware-async-stager-payload">Native first-class UUID-aware, async stager payload</h2>

<p>Make a new async payload type (based on pingback payload work) making secure comms, endpoint verification, and async communication first-class citizens, and on by default. These session types would support a much more limited set of actions than Meterpreter, only supporting sleep/upload/download/stage, but would be upgraded to Meterpreter directly as-needed (maybe even transparently). Network protocols can be much more exotic for this, and the listener/payload should be usable externally from Metasploit as well. Todo: pull in async payload proposal notes from <a href="@bwatters-r7">@bwatters-r7</a>.</p>

<h1 id="module-interface">Module Interface</h1>

<h2 id="overhaul-network-targeting">Overhaul network targeting</h2>

<p>Setting at least 5 variables RHOSTS/RPORT/SSL/VHOST/SSL_Version/User/Pass/etc… to target a single web application is very cumbersome. When these variables also do not apply to multiple RHOSTS exactly, the scheme of multiple variables falls apart futher. Metasploit should be able to target URLs directly, that can all have their own independent ports, users, hostnames, etc:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set TARGETS https://user:password@target_app:4343 https://target_app2
</code></pre></div></div>

<h2 id="overhaul-credential-targeting">Overhaul credential targeting</h2>

<p>The credential datastore options also has many different co-dependent and independent variables, which are confusing and awkward to use. In addition, there is little in the way of user-parallelism for using login scanners against single-service web apps. MSF6 should have an easier less messy overhaul of targeting multiple users and apps as well. Maybe TARGETS could be used the same way?</p>

<h2 id="collapse-module-types-expose-module-abilities-or-methods-instead">Collapse module types, expose module ‘abilities’ or ‘methods’ instead</h2>

<p>Modules in Metasploit are classified according to what they can do (‘exploits can exploit, scanners can scan’) but often its useful to be able to scan for exploitable targets. Workarounds include reaching between modules and sharing library code and mixins. This proposal suggests that ‘exploit’ and ‘scanner’, as well as many other aux-type modules should collapse into a single module type. They simply expose capabilities like ‘scan’, ‘check’, ‘exploit’, etc. and a single module can do all of these.</p>

<p>Additionally, ‘admin’ modules could be collapsed. For instance, why have a chromecast_reset and chromecast_youtube module when you can use ‘admin/chromecast’ and just type ‘cast’ or ‘reset’ as methods on this single module. This would also replace the ‘ACTIONS’ datastore option where they are used in multi-action aux modules.</p>

<h2 id="integration-with-external-exploitation-frameworks">Integration with external exploitation frameworks</h2>

<p>E.g. could we just use routersploit or wpsploit directly from within framework and gather loot/run post exploitation, etc. through them? Maybe using the external module RPC, just being able to expose multiple modules behind the same API?</p>

<h2 id="changing-module-structure-on-disk">Changing module structure on disk</h2>

<p>Currently a non-trivial exploit module will require adding code to 4 different subdirectories (lib, modules, documentation, external) which makes it both hard to follow all of the moving pieces, but also makes it harder to extract modules for independent use. See https://github.com/rapid7/metasploit-framework/wiki/Bundled-Modules-Proposal for a more detailed proposal.</p>

<h1 id="data-model">Data Model</h1>

<h2 id="temporal--log-oriented-data-model">Temporal / log-oriented data model</h2>

<p>Metasploit implements a standard Ruby-on-Rails CRUD model for storing data about an environment. A Host object is created, updated, deleted, etc. But, anything can update anything, making it easy to lose data, and hard to notice changes over time. A workaround is religious use of workspaces to segregate observations, but that’s more of a workaround. A log-structured data model (observations about hosts/loot/credentials/services, etc.) should just be objects that are imported into a datastore that prioritizes search over everything else.  Relationships between objects should be loose and maleable, as the way the graph of how objects are related can and does change over time in modern environments, often on the order of hours or minutes.</p>

<p>As a concrete example, say every <code class="highlighter-rouge">report_*</code> method just wrote a JSON blob into elasticsearch. Then you would have first observed data, and when something else happens, say a password is cracked, rather than modifying a credential object, there would just be an enrichment object added to the data store, and both could be matched together later. The current data model also often doesn’t have ways of storing arbitrary information from modules that need it; loot is often used as a workaround, but it’s not searchable by content. Providing a way to store arbitrary JSON from modules would allow the flexibility to store anything, search for anything, and to never lose anything. Also, services would be removable as well from the database when a service is down.</p>

<p>Note: a temporal data model will likely need something better able to show data relations than the current tabular rex-table approach in msfconsole. Web UI?</p>

<h2 id="data-model-is-always-available">Data model is always available</h2>

<p>The database in Metasploit has historically been optional. Not everyone needs to store data and setting up and maintaining the database is often a burden to the user, with many possible failure modes. Having the data model not always be available often complicates Metasploit’s code, and made some features like UUID tracking for payloads difficult to implement reliably. Metasploit 5 added web services for the data mode, which further complicated the code paths, adding a third way for behavior to possibly differ.</p>

<p>We should make a light-weight in-memory database service that can run automatically if a persistent database is unavailable or unconfigured, which can always provide some sort of database service to Metasploit, even if it is ephemeral and exits when msfconsole/listeners, etc. have exited. <code class="highlighter-rouge">framework.db</code> should always exist, even if the data it stores goes into a temporary bit bucket. Then all of the conditional code paths can go away.</p>

<h1 id="infrastructure">Infrastructure</h1>

<h2 id="first-class-user-oriented-documentation">First class user-oriented documentation</h2>

<p>Provide a means for the community to document changes to how Metasploit works (developer and user), unify various documentation resources.</p>

<h2 id="make-metasploit-higher-performance--lighter-weight">Make Metasploit Higher-performance / lighter weight</h2>

<p>As subcomponents get carved off (external database service, external listeners), they should be implemented in a lighter weight way. We have some prototypes of the database web service rewritten in golang, and a persistent payload generation service that can be used my a client-only <code class="highlighter-rouge">msfvenom</code>-like tool can speed up execution considerably.</p>

<h2 id="sunsetting-separation-of-old-module--code">Sunsetting, separation of old module / code</h2>

<p>Metasploit has some really old modules that probably don’t get used very often. Can we segregate these or sunset them so that the overall number of modules is reduced?</p>

<h2 id="integration-of-separate-metasploit-projects-into-fewer-repos-rex--payloads--metasploit-data-models">Integration of separate Metasploit projects into fewer repos (rex / payloads / metasploit data models)</h2>

<p>Metasploit is spread out across over a dozen different repos. Let’s merge them as much as we can to make it easier to change them across the board (e.g. when changing the data model) and to make it easier to have parallel branches for stable/unstable work.</p>

  </div><a class="u-url" href="/metasploit-framework/articles/MSF6-Feature-Proposals.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/metasploit-framework/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Metasploit spike</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Metasploit spike</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/metasploit-framework/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/metasploit-framework/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
